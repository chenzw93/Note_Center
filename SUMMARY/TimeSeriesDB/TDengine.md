**基于TDengine V2.6版本**



## 概念

[官方文档](https://docs.taosdata.com/2.6/concept/)

### 表

* 一个点就是一张表
* 表的第一列必须是时间戳，即数据类型为 timestamp
* 数据用列式存储方式保存

### 超级表

* 某一特定类型的数据采集点的集合(不同Tag的统一类型的点，属于一个超级表)

* 有多少不同类型的点，就要有多少种超级表

出现原因有两点：

* 表数据巨大
* 多个点直接进行聚合操作

**表用来代表一个具体的数据采集点，超级表用来代表一组相同类型的数据采集点集合**

### 库

* 不同的库可以配置不同的存储策略（保留时长、副本数、内存块个数、时间精度、文件块里最大最小记录条数、是否压缩、一个数据文件覆盖的天数）
* 建议不同数据特征的超级表创建在不同的数据库（最大效率工作）

### 节点

[节点描述官网](https://docs.taosdata.com/2.6/tdinternal/arch/)

* 物理节点
* 数据节点
  * 至少一个数据节点
* 虚拟节点
  * 为更好的支持**数据分片**、**负载均衡**，为更好的支持数据分片、负载均衡，防止数据过热或倾斜，**数据节点被虚拟化成多个虚拟节点**，数据节点被虚拟化成多个虚拟节点
  * 每个 vnode 都是一个相对独立的工作单元，是时序数据存储的基本单元，具有独立的运行线程、内存空间与持久化存储的路径
  * 一个 vnode 包含一定数量的表（数据采集点）
  * 当创建一张新表时，系统会检查是否需要创建新的 vnode
* 管理节点
  * 负责所有数据节点运行状态的监控和维护，以及节点之间的负载均衡
  * 管理节点也负责元数据（包括用户、数据库、表、静态标签等）的存储和管理，因此也称为 Meta Node
  * mnode 间采用 master/slave 的机制进行管理，而且采取强一致方式进行数据同步，任何数据更新操作只能在 Master 上进行。mnode 集群的创建由系统自动完成，无需人工干预
* 虚拟节点组
  * 虚拟节点组内采取 master/slave 的方式进行管理。写操作只能在 master vnode 上进行，系统采用异步复制的方式将数据同步到 slave vnode，这样确保了一份数据在多个物理节点上有拷贝

### 节点通讯

各个数据节点之间，以及应用驱动与各数据节点之间的通讯是通过 TCP/UDP 进行的

* 对于数据量不到 15K 的数据包，采取 UDP 的方式进行传输，超过 15K 的，或者是查询类的操作，自动采取 TCP 的方式进行传输
* 根据配置和数据包，会自动对数据进行压缩/解压缩，数字签名/认证等处理。对于数据节点之间的数据复制，只采用 TCP 方式进行数据传输

## 特点

### 高效写入/查询如何保证

高性能，可以支持百万级别的并发写入、万级的并发读取，大量聚合查询时依然有高性能表现

#### 写入

* 由于不同数据采集点产生数据的过程完全独立，每个数据采集点的数据源是唯一的，一张表也就只有一个写入者，这样就可采用无锁方式来写，写入速度就能大幅提升。
* 对于一个数据采集点而言，其产生的数据是按照时间排序的，因此写的操作可用追加的方式实现，进一步大幅提高数据写入速度。

#### 查询

* 一个数据采集点的数据是以块为单位连续存储的。如果读取一个时间段的数据，它能大幅减少随机读取操作，成数量级的提升读取和查询速度。
* 一个数据块内部，采用列式存储，对于不同数据类型，采用不同压缩算法，而且由于一个数据采集点的采集量的变化是缓慢的，压缩率更高。

### 高效数据压缩

* 数据列式存储

### 流式计算如何实现



## 消息流程



为解释 vnode、mnode、taosc 和应用之间的关系以及各自扮演的角色，下面对写入数据这个典型操作的流程进行剖析。

![TDengine Database 典型的操作流程](https://docs.taosdata.com/assets/images/message-36f7ae20178c733675e574a97fc22e9b.webp)

1. 应用通过 JDBC 或其他 API 接口发起插入数据的请求。
2. taosc 会检查缓存，看是否保存有该表的 meta data。如果有，直接到第 4 步。如果没有，taosc 将向 mnode 发出 get meta-data 请求。
3. mnode 将该表的 meta-data 返回给 taosc。Meta-data 包含有该表的 schema，而且还有该表所属的 vgroup 信息（vnode ID 以及所在的 dnode 的 End Point，如果副本数为 N，就有 N 组 End Point）。如果 taosc 迟迟得不到 mnode 回应，而且存在多个 mnode，taosc 将向下一个 mnode 发出请求。
4. taosc 向 master vnode 发起插入请求。
5. vnode 插入数据后，给 taosc 一个应答，表示插入成功。如果 taosc 迟迟得不到 vnode 的回应，taosc 会认为该节点已经离线。这种情况下，如果被插入的数据库有多个副本，taosc 将向 vgroup 里下一个 vnode 发出插入请求。
6. taosc 通知 APP，写入成功。

对于第二和第三步，taosc 启动时，并不知道 mnode 的 End Point，因此会直接向配置的集群对外服务的 End Point 发起请求。如果接收到该请求的 dnode 并没有配置 mnode，该 dnode 会在回复的消息中告知 mnode EP 列表，这样 taosc 会重新向新的 mnode 的 EP 发出获取 meta-data 的请求。

对于第四和第五步，没有缓存的情况下，taosc 无法知道虚拟节点组里谁是 master，就假设第一个 vnodeID 就是 master，向它发出请求。如果接收到请求的 vnode 并不是 master，它会在回复中告知谁是 master，这样 taosc 就向建议的 master vnode 发出请求。一旦得到插入成功的回复，taosc 会缓存 master 节点的信息。

上述是插入数据的流程，查询、计算的流程也完全一致。taosc 把这些复杂的流程全部封装屏蔽了，对于应用来说无感知也无需任何特别处理。

通过 taosc 缓存机制，只有在第一次对一张表操作时，才需要访问 mnode，因此 mnode 不会成为系统瓶颈。但因为 schema 有可能变化，而且 vgroup 有可能发生改变（比如负载均衡发生），因此 taosc 会定时和 mnode 交互，自动更新缓存。